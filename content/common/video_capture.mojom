// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module content.mojom;

import "gpu/ipc/common/sync_token.mojom";
import "media/mojo/interfaces/media_types.mojom";
import "mojo/common/common_custom_types.mojom";
import "services/video_capture/public/interfaces/video_capture_device_proxy.mojom";
import "services/video_capture/public/interfaces/video_capture_format.mojom";
import "ui/gfx/geometry/mojo/geometry.mojom";

struct VideoCaptureParams {
  video_capture.mojom.VideoCaptureFormat requested_format;
  video_capture.mojom.ResolutionChangePolicy resolution_change_policy;
  video_capture.mojom.PowerLineFrequency power_line_frequency;
};

struct VideoFrameInfo{
  mojo.common.mojom.TimeDelta timestamp;
  mojo.common.mojom.DictionaryValue metadata;
  media.mojom.VideoPixelFormat pixel_format;
  video_capture.mojom.VideoPixelStorage storage_type;
  gfx.mojom.Size coded_size;
  gfx.mojom.Rect visible_rect;
};

enum VideoCaptureState {
  STARTED,
  PAUSED,
  RESUMED,
  STOPPED,
  FAILED,
  ENDED,
};

// Interface for notifications from Browser/Host back to Renderer/Client. This
// interface is used between VideoCaptureHost.Start() and Stop().
interface VideoCaptureObserver {
  // Gets notified about a VideoCaptureState update.
  OnStateChanged(VideoCaptureState state);

  // |buffer_id| has video capture data with |info| containing the associated
  // VideoFrame constituent parts.
  OnBufferReady(int32 buffer_id, VideoFrameInfo info);

  // |buffer_id| has been released by VideoCaptureHost and must not be used.
  OnBufferDestroyed(int32 buffer_id);

  // TODO(mcasas): Migrate the rest of the messages, https://crbug.com/651897.
};

interface VideoCaptureHost {
  // Start the |session_id| session with |params|. The video capture will be
  // identified as |device_id|, a new id picked by the renderer process.
  // |observer| will be used for notifications.
  Start(int32 device_id, int32 session_id, VideoCaptureParams params,
        VideoCaptureObserver observer);

  // Closes the video capture specified by |device_id|.
  Stop(int32 device_id);

  // Pauses the video capture specified by |device_id|.
  Pause(int32 device_id);

  // Resume |device_id| video capture, in |session_id| and with |params|.
  Resume(int32 device_id, int32 session_id, VideoCaptureParams params);

  // Requests that the video capturer send a frame "soon" (e.g., to resolve
  // picture loss or quality issues).
  RequestRefreshFrame(int32 device_id);

  // Indicates that a renderer has finished using a previously shared buffer.
  ReleaseBuffer(int32 device_id, int32 buffer_id,
                gpu.mojom.SyncToken sync_token,
                double consumer_resource_utilization);

  // Get the formats supported by a device referenced by |session_id|.
  GetDeviceSupportedFormats(int32 device_id, int32 session_id)
    => (array<video_capture.mojom.VideoCaptureFormat> formats_supported);

  // Get the format(s) in use by a device referenced by |session_id|.
  GetDeviceFormatsInUse(int32 device_id, int32 session_id)
    => (array<video_capture.mojom.VideoCaptureFormat> formats_in_use);
};
